"use strict";

const dedent = require("dedent");

const fileContents = require("./file-contents");

describe("fileContents", () => {
    const markdownForTree = "markdownForTree";
    const endOfLine = "\n";

    describe("getTitleParagraphFromContents", () => {
        test("it should handle empty files", () => {
            const contents = "";
            expect(fileContents.getTitleParagraphFromContents(contents)).toBeUndefined();
        });

        test("it should handle empty title", () => {
            const contents = "# ";
            expect(fileContents.getTitleParagraphFromContents(contents)).toBe("");
        });

        test("it should support CRLF line endings", () => {
            const contents = "# test" + "\r\n" + "second line";
            expect(fileContents.getTitleParagraphFromContents(contents)).toBe("test");
        });

        test("it should support LF line endings", () => {
            const contents = "# test" + "\n" + "second line";
            expect(fileContents.getTitleParagraphFromContents(contents)).toBe("test");
        });

        test("it should support CR line endings", () => {
            const contents = "# test" + "\r" + "second line";
            expect(fileContents.getTitleParagraphFromContents(contents)).toBe("test");
        });

        test("it should ignore starting empty lines", () => {
            const contents = "\n" + "\n" + "# test";
            expect(fileContents.getTitleParagraphFromContents(contents)).toBe("test");
        });

        test("it should ignore the directory README start marker", () => {
            const contents = dedent(
                `<!-- generated by markdown-notes-tree -->
                
                # test`
            );

            expect(fileContents.getTitleParagraphFromContents(contents)).toBe("test");
        });

        test("it should ignore the old directory README start marker", () => {
            const contents = dedent(
                `<!-- this entire file is auto-generated -->
                
                # test`
            );

            expect(fileContents.getTitleParagraphFromContents(contents)).toBe("test");
        });

        test("it should return the tree title from YAML front matter if available", () => {
            const contents = dedent(
                `---
                tree_title: TreeTitle
                ---
                
                # test
                second line`
            );

            expect(fileContents.getTitleParagraphFromContents(contents)).toBe("TreeTitle");
        });

        test("it should escape Markdown syntax in title from YAML front matter", () => {
            const contents = dedent(
                `---
                tree_title: _TreeTitle_
                ---
                
                # test
                second line`
            );

            expect(fileContents.getTitleParagraphFromContents(contents)).toBe("\\_TreeTitle\\_");
        });

        test("it should ignore YAML front matter that has no tree_title attribute", () => {
            const contents = dedent(
                `---
                description: Some text
                ---
                
                # test
                second line`
            );

            expect(fileContents.getTitleParagraphFromContents(contents)).toBe("test");
        });

        test("it should return undefined if the file doesn't have a title", () => {
            const contents = "some non-title content";
            expect(fileContents.getTitleParagraphFromContents(contents)).toBeUndefined();
        });

        test("it should support content before the title", () => {
            const contents = dedent(
                `content before title
                
                # test

                some other content`
            );

            expect(fileContents.getTitleParagraphFromContents(contents)).toBe("test");
        });

        test("it should properly escape markdown characters inside the title heading", () => {
            const contents = dedent(
                `# * test

                some other content`
            );

            expect(fileContents.getTitleParagraphFromContents(contents)).toBe("\\* test");
        });

        test("it should fail if title contains content that is not supported inside links", () => {
            const contents = dedent(
                `# test [mistermicheels](http://mistermicheels.com)

                some other content`
            );

            expect(() => fileContents.getTitleParagraphFromContents(contents)).toThrow(
                "Title cannot contain Markdown links since this would mess up the links in the tree (consider using HTML as a workaround)"
            );
        });
    });

    describe("getNewMainReadmeContents", () => {
        test("it should handle current contents without a tree", () => {
            const currentContents = "some content";

            const result = fileContents.getNewMainReadmeContents(currentContents, markdownForTree, {
                endOfLine
            });

            const expected =
                dedent(`some content
                
                <!-- tree generated by markdown-notes-tree starts here -->
                
                ${markdownForTree}
                
                <!-- tree generated by markdown-notes-tree ends here -->`) + endOfLine;

            expect(result).toBe(expected);
        });

        test("it should handle current contents with a tree", () => {
            const currentContents =
                dedent(`some content
                
                <!-- tree generated by markdown-notes-tree starts here -->
                
                ${markdownForTree}
                
                <!-- tree generated by markdown-notes-tree ends here -->
                
                content after tree`) + endOfLine;

            const result = fileContents.getNewMainReadmeContents(currentContents, markdownForTree, {
                endOfLine
            });

            const expected =
                dedent(`some content
                
                <!-- tree generated by markdown-notes-tree starts here -->
                
                ${markdownForTree}
                
                <!-- tree generated by markdown-notes-tree ends here -->
                
                content after tree`) + endOfLine;

            expect(result).toBe(expected);
        });

        test("it should handle current contents with a tree and old markers (v1.8.0 and earlier)", () => {
            const currentContents =
                dedent(`some content
                
                <!-- auto-generated notes tree starts here -->
                
                ${markdownForTree}
                
                <!-- auto-generated notes tree ends here -->
                
                content after tree`) + endOfLine;

            const result = fileContents.getNewMainReadmeContents(currentContents, markdownForTree, {
                endOfLine
            });

            const expected =
                dedent(`some content
                
                <!-- tree generated by markdown-notes-tree starts here -->
                
                ${markdownForTree}
                
                <!-- tree generated by markdown-notes-tree ends here -->
                
                content after tree`) + endOfLine;

            expect(result).toBe(expected);
        });

        test("it should handle current contents with a tree at the end missing the end marker (as generated by older version)", () => {
            const currentContents =
                dedent(`some content
                
                <!-- tree generated by markdown-notes-tree starts here -->
                
                ${markdownForTree}`) + endOfLine;

            const result = fileContents.getNewMainReadmeContents(currentContents, markdownForTree, {
                endOfLine
            });

            const expected =
                dedent(`some content
                
                <!-- tree generated by markdown-notes-tree starts here -->
                
                ${markdownForTree}
                
                <!-- tree generated by markdown-notes-tree ends here -->`) + endOfLine;

            expect(result).toBe(expected);
        });

        test("it should fail for current contents having an end marker before start marker", () => {
            const currentContents =
                dedent(`some content

                <!-- tree generated by markdown-notes-tree ends here -->
                
                <!-- tree generated by markdown-notes-tree starts here -->
                
                ${markdownForTree}`) + endOfLine;

            expect(() =>
                fileContents.getNewMainReadmeContents(currentContents, markdownForTree, {
                    endOfLine
                })
            ).toThrow("Invalid file structure: tree end marker found before tree start marker");
        });

        test("it should fail for current contents having an end marker but no start marker", () => {
            const currentContents =
                dedent(`some content

                <!-- tree generated by markdown-notes-tree ends here -->
                
                ${markdownForTree}`) + endOfLine;

            expect(() =>
                fileContents.getNewMainReadmeContents(currentContents, markdownForTree, {
                    endOfLine
                })
            ).toThrow("Invalid file structure: tree end marker found before tree start marker");
        });

        test("it should ignore markers inside code snippets etc.", () => {
            const currentContents =
                dedent(`some content

                \`<!-- tree generated by markdown-notes-tree ends here -->\`
                
                ${markdownForTree}`) + endOfLine;

            expect(() =>
                fileContents.getNewMainReadmeContents(currentContents, markdownForTree, {
                    endOfLine
                })
            ).not.toThrow();
        });

        test("it should not touch old markers inside code snippets etc.", () => {
            const currentContents = "old marker: `<!-- auto-generated notes tree starts here -->`";

            const result = fileContents.getNewMainReadmeContents(currentContents, markdownForTree, {
                endOfLine
            });

            const expected =
                dedent(`old marker: \`<!-- auto-generated notes tree starts here -->\`
                
                <!-- tree generated by markdown-notes-tree starts here -->
                
                ${markdownForTree}
                
                <!-- tree generated by markdown-notes-tree ends here -->`) + endOfLine;

            expect(result).toBe(expected);
        });
    });

    describe("getNewDirectoryReadmeContents", () => {
        const titleParagraph = "titleParagraph";

        const upwardNavigationPaths = {
            oneLevelUp: "oneLevelUpPath",
            toTopLevel: "toTopLevelPath"
        };

        const basicContents =
            dedent(`<!-- generated by markdown-notes-tree -->

            # ${titleParagraph}

            <!-- optional markdown-notes-tree directory description starts here -->

            <!-- optional markdown-notes-tree directory description ends here -->
        
            ${markdownForTree}`) + endOfLine;

        test("it should handle empty current contents", () => {
            const currentContents = "";

            const result = fileContents.getNewDirectoryReadmeContents(
                titleParagraph,
                upwardNavigationPaths,
                currentContents,
                markdownForTree,
                { endOfLine, options: { includeUpwardNavigation: false } }
            );

            expect(result).toBe(basicContents);
        });

        test("it should handle current contents without description markers", () => {
            const currentContents =
                dedent(`<!-- generated by markdown-notes-tree -->
                
                # ${titleParagraph}
                
                ${markdownForTree}`) + endOfLine;

            const result = fileContents.getNewDirectoryReadmeContents(
                titleParagraph,
                upwardNavigationPaths,
                currentContents,
                markdownForTree,
                { endOfLine, options: { includeUpwardNavigation: false } }
            );

            expect(result).toBe(basicContents);
        });

        test("it should handle current contents with description ", () => {
            const result = fileContents.getNewDirectoryReadmeContents(
                titleParagraph,
                upwardNavigationPaths,
                basicContents,
                markdownForTree,
                { endOfLine, options: { includeUpwardNavigation: false } }
            );

            expect(result).toBe(basicContents);
        });

        test("it should preserve user-managed content", () => {
            const contentsWithUserManagedContent =
                dedent(`<!-- generated by markdown-notes-tree -->

                User-managed content before title
                    
                # ${titleParagraph}

                User-managed content after title

                <!-- optional markdown-notes-tree directory description starts here -->

                User-managed description text

                <!-- optional markdown-notes-tree directory description ends here -->
            
                ${markdownForTree}`) + endOfLine;

            const result = fileContents.getNewDirectoryReadmeContents(
                titleParagraph,
                upwardNavigationPaths,
                contentsWithUserManagedContent,
                markdownForTree,
                { endOfLine, options: { includeUpwardNavigation: false } }
            );

            expect(result).toBe(contentsWithUserManagedContent);
        });

        describe("upward navigation handling", () => {
            const basicContentsIncludingUpwardNavigation =
                dedent(`<!-- generated by markdown-notes-tree -->

                <!-- upward navigation links generated by markdown-notes-tree start here -->

                [Go one level up](${upwardNavigationPaths.oneLevelUp}) / [Go to top level](${upwardNavigationPaths.toTopLevel})

                <!-- upward navigation links generated by markdown-notes-tree end here -->
            
                # ${titleParagraph}

                <!-- optional markdown-notes-tree directory description starts here -->

                <!-- optional markdown-notes-tree directory description ends here -->
            
                ${markdownForTree}`) + endOfLine;

            test("it should be able to add upward navigation links if needed", () => {
                const result = fileContents.getNewDirectoryReadmeContents(
                    titleParagraph,
                    upwardNavigationPaths,
                    basicContents,
                    markdownForTree,
                    { endOfLine, options: { includeUpwardNavigation: true } }
                );

                expect(result).toBe(basicContentsIncludingUpwardNavigation);
            });

            test("it should be able to preserve existing upward navigation links if needed", () => {
                const result = fileContents.getNewDirectoryReadmeContents(
                    titleParagraph,
                    upwardNavigationPaths,
                    basicContentsIncludingUpwardNavigation,
                    markdownForTree,
                    { endOfLine, options: { includeUpwardNavigation: true } }
                );

                expect(result).toBe(basicContentsIncludingUpwardNavigation);
            });

            test("it should be able to remove existing upward navigation links if needed", () => {
                const result = fileContents.getNewDirectoryReadmeContents(
                    titleParagraph,
                    upwardNavigationPaths,
                    basicContentsIncludingUpwardNavigation,
                    markdownForTree,
                    { endOfLine, options: { includeUpwardNavigation: false } }
                );

                expect(result).toBe(basicContents);
            });
        });
    });

    describe("getDirectoryDescriptionParagraphFromCurrentContents", () => {
        test("it should handle empty current contents", () => {
            const currentContents = "";

            const result = fileContents.getDirectoryDescriptionParagraphFromCurrentContents(
                currentContents
            );
            expect(result).toBe("");
        });

        test("it should handle current contents without description markers (as generated by older version)", () => {
            const currentContents =
                dedent(`<!-- generated by markdown-notes-tree -->
                
                # titleParagraph
                
                ${markdownForTree}`) + endOfLine;

            const result = fileContents.getDirectoryDescriptionParagraphFromCurrentContents(
                currentContents
            );

            expect(result).toBe("");
        });

        test("it should handle current contents without description between markers", () => {
            const currentContents =
                dedent(`<!-- generated by markdown-notes-tree -->
                
                # titleParagraph

                <!-- optional markdown-notes-tree directory description starts here -->

                <!-- optional markdown-notes-tree directory description ends here -->
                
                ${markdownForTree}`) + endOfLine;

            const result = fileContents.getDirectoryDescriptionParagraphFromCurrentContents(
                currentContents
            );

            expect(result).toBe("");
        });

        test("it should handle current contents with description between markers", () => {
            const currentContents =
                dedent(`<!-- generated by markdown-notes-tree -->
                
                # titleParagraph

                <!-- optional markdown-notes-tree directory description starts here -->

                This is a description.

                <!-- optional markdown-notes-tree directory description ends here -->
                
                ${markdownForTree}`) + endOfLine;

            const result = fileContents.getDirectoryDescriptionParagraphFromCurrentContents(
                currentContents
            );

            expect(result).toBe("This is a description.");
        });

        test("it should handle current contents with description between markers and old start marker (v1.8.0 and earlier)", () => {
            const currentContents =
                dedent(`<!-- this entire file is auto-generated -->
                
                # titleParagraph

                <!-- optional markdown-notes-tree directory description starts here -->

                This is a description.

                <!-- optional markdown-notes-tree directory description ends here -->
                
                ${markdownForTree}`) + endOfLine;

            const result = fileContents.getDirectoryDescriptionParagraphFromCurrentContents(
                currentContents
            );

            expect(result).toBe("This is a description.");
        });

        test("it should fail for current contents having invalid markers", () => {
            const currentContents =
                dedent(`<!-- generated by markdown-notes-tree -->
                
                # titleParagraph

                <!-- optional markdown-notes-tree directory description ends here -->

                <!-- optional markdown-notes-tree directory description starts here -->
                
                ${markdownForTree}`) + endOfLine;

            expect(() =>
                fileContents.getDirectoryDescriptionParagraphFromCurrentContents(currentContents)
            ).toThrow(
                "Invalid file structure: only one description marker found or end marker found before start marker"
            );
        });

        test("it should fail for current contents where description is not just a single paragraph", () => {
            const currentContents =
                dedent(`<!-- generated by markdown-notes-tree -->
                
                # titleParagraph

                <!-- optional markdown-notes-tree directory description starts here -->

                This is a description.

                This will:
                - Mess up formatting
                - Give me headaches

                <!-- optional markdown-notes-tree directory description ends here -->
                
                ${markdownForTree}`) + endOfLine;

            expect(() =>
                fileContents.getDirectoryDescriptionParagraphFromCurrentContents(currentContents)
            ).toThrow("Subdirectory description should be just a single paragraph");
        });
    });
});
