"use strict";

const frontMatter = require("front-matter");

module.exports = {
    getTitleFromMarkdownContents,
    getNewMainReadmeContents,
    getNewDirectoryReadmeContents,
    getDirectoryDescriptionFromCurrentContents
};

const markers = {
    mainReadmeTreeStart: "<!-- tree generated by markdown-notes-tree starts here -->",
    mainReadmeTreeEnd: "<!-- tree generated by markdown-notes-tree ends here -->",
    directoryReadmeStart: "<!-- generated by markdown-notes-tree -->",
    directoryReadmeDescriptionStart:
        "<!-- optional markdown-notes-tree directory description starts here -->",
    directoryReadmeDescriptionEnd:
        "<!-- optional markdown-notes-tree directory description ends here -->",
    mainReadmeTreeStart_v_1_8_0: "<!-- auto-generated notes tree starts here -->",
    mainReadmeTreeEnd_v_1_8_0: "<!-- auto-generated notes tree ends here -->",
    directoryReadmeStart_v_1_8_0: "<!-- this entire file is auto-generated -->"
};

function getTitleFromMarkdownContents(contents) {
    contents = normalizeContents(contents);

    const parsedFrontMatter = frontMatter(contents);
    const titleFromFrontMatter = parsedFrontMatter.attributes.tree_title;

    if (titleFromFrontMatter) {
        return titleFromFrontMatter;
    }

    const contentsWithoutFrontMatter = parsedFrontMatter.body.trimLeft();
    const lines = contentsWithoutFrontMatter.split(/\r\n|\r|\n/);

    for (const line of lines) {
        if (line.startsWith("# ")) {
            return line.substring(2);
        } else if (line !== "" && line !== markers.directoryReadmeStart) {
            return undefined;
        }
    }

    return undefined;
}

function getNewMainReadmeContents(currentContents, markdownForTree, environment) {
    currentContents = normalizeContents(currentContents);

    const indexTreeStartMarker = currentContents.indexOf(markers.mainReadmeTreeStart);
    const treeStartMarkerPresent = indexTreeStartMarker >= 0;
    let contentsBeforeTree;

    if (treeStartMarkerPresent) {
        contentsBeforeTree = currentContents.substring(0, indexTreeStartMarker);
    } else {
        contentsBeforeTree = currentContents + environment.endOfLine.repeat(2);
    }

    const indexTreeEndMarker = currentContents.indexOf(markers.mainReadmeTreeEnd);
    const treeEndMarkerPresent = indexTreeEndMarker >= 0;
    let contentsAfterTree;

    const treeEndMarkerValid =
        treeEndMarkerPresent && treeStartMarkerPresent && indexTreeEndMarker > indexTreeStartMarker;

    if (treeEndMarkerValid) {
        contentsAfterTree = currentContents.substring(
            indexTreeEndMarker + markers.mainReadmeTreeEnd.length
        );
    } else if (treeEndMarkerPresent) {
        throw new Error("Invalid file structure: tree end marker found before tree start marker");
    } else {
        contentsAfterTree = environment.endOfLine;
    }

    return (
        contentsBeforeTree +
        markers.mainReadmeTreeStart +
        environment.endOfLine.repeat(2) +
        markdownForTree +
        environment.endOfLine.repeat(2) +
        markers.mainReadmeTreeEnd +
        contentsAfterTree
    );
}

function normalizeContents(contents) {
    return contents
        .replace(markers.mainReadmeTreeStart_v_1_8_0, markers.mainReadmeTreeStart)
        .replace(markers.mainReadmeTreeEnd_v_1_8_0, markers.mainReadmeTreeEnd)
        .replace(markers.directoryReadmeStart_v_1_8_0, markers.directoryReadmeStart)
        .trimLeft();
}

function getNewDirectoryReadmeContents(name, currentContents, markdownForTree, environment) {
    currentContents = normalizeContents(currentContents);

    const currentTitle = getTitleFromMarkdownContents(currentContents);
    const title = currentTitle || name;
    const titleLine = `# ${title}`;

    const description = getDirectoryDescriptionFromCurrentContents(currentContents);

    let partBetweenDescriptionMarkers = environment.endOfLine.repeat(2);

    if (description) {
        partBetweenDescriptionMarkers =
            environment.endOfLine.repeat(2) + description + environment.endOfLine.repeat(2);
    }

    return (
        markers.directoryReadmeStart +
        environment.endOfLine.repeat(2) +
        titleLine +
        environment.endOfLine.repeat(2) +
        markers.directoryReadmeDescriptionStart +
        partBetweenDescriptionMarkers +
        markers.directoryReadmeDescriptionEnd +
        environment.endOfLine.repeat(2) +
        markdownForTree +
        environment.endOfLine
    );
}

function getDirectoryDescriptionFromCurrentContents(currentContents) {
    const indexStartMarker = currentContents.indexOf(markers.directoryReadmeDescriptionStart);
    const indexEndMarker = currentContents.indexOf(markers.directoryReadmeDescriptionEnd);

    const startMarkerPresent = indexStartMarker >= 0;
    const endMarkerPresent = indexEndMarker >= 0;

    const markersValid =
        startMarkerPresent && endMarkerPresent && indexEndMarker > indexStartMarker;

    if (markersValid) {
        const descriptionStart = indexStartMarker + markers.directoryReadmeDescriptionStart.length;
        const descriptionEnd = indexEndMarker;

        return currentContents.substring(descriptionStart, descriptionEnd).trim();
    } else if (startMarkerPresent || endMarkerPresent) {
        throw new Error(
            "Invalid file structure: only one description marker found or end marker found before start marker"
        );
    } else {
        return "";
    }
}
